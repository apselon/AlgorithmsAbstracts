\section{Суффиксный массив. LCP. Алгоритм Касаи и др.}
\subsection{Суффиксный массив.}

\subsubsection{Определение.}
Пусть у нас имеется строка $T = "ababbacba"$.
\begin{Def} \ \\
    \textbf{Суффиксный массив} строки $T$ --- отсортированный лексикографически массив ее суффиксов.
\end{Def}

\begin{example}
Для нашей строки $T$ суффиксный массив имеет вид:
\begin{enumerate}
    \item $\emptyset$
    \item $"a"$
    \item $"ababbacba"$
    \item $"abbacba"$
    \item $"acba"$
    \item $"ba"$
    \item $"babbacba"$
    \item $"bacba"$
    \item $"bbacba"$
    \item $"cba"$
\end{enumerate}
\end{example}

Для удобства хранения, \textbf{мы можем отождествим суффикс с номером символа в $T$, с которого он начинается}.

\subsubsection{Построение.}
Соберем номера символов, с которых начинается каждый из суффиксов в массив.

Сортировать можно несколькими способами:
Взять все суффиксы и отсортировать, сравнивая строки посимвольно. $\Theta(n ^ 2 \log n)$ \
Или же, одсчитав хэши для $T$, бинарным поиском находить наибольший общий префикс двух суффиксов, а затем сравним первые отличающиеся символы. $\Theta(n \log ^ 2 n)$, делая $n \log{n}$ сравнений, каждое за $\log{n}$.
Стоит помнить о том, что хэши неточны.


Однако можем делать это еще быстрее.
В конец $T$ допишем символ \$, а затем продолжим каждый суффикс, чтобы он имел вид циклического сдвига исходной строки $T$.

\begin{example}   \
\begin{enumerate}
    \item "\$"
    \item $"a\color{blue}\$ababbacb"$
    \item $"ababbacba\color{blue}\$"$
    \item $"abbacba\color{blue}\$ab"$
    \item $"acba\color{blue}\$ababb"$
    \item $"ba\color{blue}\$ababbac"$
    \item $"babbacba\color{blue}\$a"$
    \item $"bacba\color{blue}\$abab"$
    \item $"bbacba\color{blue}\$aba"$
    \item $"cba\color{blue}\$ababba"$
\end{enumerate}
\end{example}

Будем считать что лексикографический номер символа \$ меньше чем у любого другого. Таким образом лексикографический порядок сдвига будет совпадать с порядком соответствующего ему суффикса.
Мы свели задачу сортировки суффиксов к задаче сортировки циклических сдвигов строки.
Для удобства сортировки, \textbf{будем считать циклический сдвиг строки бесконечным, тогда все индексы будем брать по модулю длины строки}.

Разделим сортировку на этапы, и на $k$-том этапе будем сортировать префиксы бесконечных циклических сдвигов строки, имеющие длину $2 ^ k$.
Будем повторять их пока $2 ^ k \leq \lvert T \rvert$

\begin{example}
\underline{$k = 0$}:
        Префикс длины $1$ --- просто первый символ. Так как размах сортируемых значений ограничен воспользоваться сортировкой подсчетом. \\
        Таким образом, мы разбили все сдвиги на блоки по первой букве. Сами блоки отсортированы, однако сдвиги внутри них имеют произвольный порядок.
\end{example}
Тогда каждому сдвигу поставим в соответствие номер --- класс эквивалентности по префиксу некоторой длины, так чтобы лексикграфически большим префиксам соответствовал больший номер класса.
Пусть $C[i]$ --- класс эквивалентности сдвига, начинающегося с позиции  $i$.

Пусть мы находимся на $k$-том шаге:
Мы имеем разбиение сдвигов длины $2 ^ {k - 1}$ на классы, теперь необходимо проделать то же самое со сдвигами длины  $2 ^ k$.
Вспомним что сдвиг длины $2 ^ k$ состоит из двух половин, классы которых мы посчитали на прошлом шаге. Тогда сравнение сдвигов длины  $2 ^ k$ сводится к сравнению пар $(C[i], C[i + 2 ^ {k - 1}])$ и $(C[j], C[j + 2 ^ {k - 1}])$.

Чтобы посчитать классы эквивалентности всех сдвигов по длине $2 ^ k$, мы должны просто взять все пары вида $(C[i], C[i + 2 ^ {k - 1}])$ и стабильно отсортировать их по второму элементу. 
Затем пройдемся по массиву, и расставим классы эквивалентности, увеличивая номер класса при изменении рассматриваемой пары. 

\subsection{Наибольший общий префикс.}
Хотим для двух данных суффиксов строки $T$ найти наибольший общий префикс. Обозначим его  $LCP$. \\
Для каждого элемента суффиксного массива подсчитаем его $LCP$ со следующим элементом.

\begin{prop}\label{1}
    Если $i$-ый и  $j$-ый элементы суффиксного массива имеют общий префикс длины  $l$, то и все элементы с индексами между  $i$ и  $j$ имеют такой же префикс длины  $l$.
\end{prop}

\begin{proof}
    Действительно, ведь суффиксный массив отсортирован лексикографически.
\end{proof}

Пусть $W[i]$ --- позиция  $i$-того суффикса в суффиксном массиве.
Пусть $P[i]$ --- суффикс, соответствующий  $i$-тому элементу суффиксного массива.

Тогда наибольший общий префикс двух суффиксов $i, j$ $LCP(i, j) = \min \limits_{W[i] \leq m \leq n \leq W[j]} LCP(P[m], P[n])$, из утверждения \ref{1}, ведь $LCP$ 
любых двух соседей точно не меньше этой величины, значит у любых суффиксов между  $i$ и  $j$ имеется такой общий префикс, а значит и у  $i$ с  $j$ он тоже имеется.
\\
Минимум на отрезке мы умеем считать при помощи sparse table.
Возникает вопрос, как оптимально посчитать $LCP$ соседних в массиве суффиксов?

\subsection{Решение с помощью промежуточных шагов.}
Будем хранить разбиения на классы эквивалентности на каждом шаге, тогда сравнение строк длины $2^k$ сведется к сравнению  $C_k[i] == C_k[j]$. \\
Если они равны, то можем откусить префиксы длины $2^k$ и сравнить дальше, иначе же уменьшим $k$ в два раза.
Для каждой пары соседних суффиксов мы перебираем  $k$ от  $0$ до $\log{n}$, значит работать это будет за  $O(n\log{n})$.

\subsubsection{Алгоритм Касаи, Аримуры, Арикавы, Ли, Парка}
Пусть $L[i] = LCP(P[i], P[i + 1])$. \\
Заметим, что  $L[W[P[i] + 1]] \geq L[i] - 1$, ведь у если у суффикса $P[i]$ имелся общий префикс с суффиксом  $P[i + 1]$ длины  $L[i]$, то у суффикса  $P[i] + 1$, полученного из  $P[i]$ отбрасыванием первого символа, точно будет общая часть длины  $L[i] - 1$ с суффиксом  $P[i + 1] + 1$.  $P[i] + 1$ и  $P[i + 1] + 1$ вовсе не обязательно будут соседствовать в суффиксном массиве, но из \ref{1} получим необходимое неравенство. Получив оценку, точно значение будем вычислять наивно.
\begin{lstlisting}[language = C++]
auto L = vector(n);
int current_lcp = 0;

for (size_t i = 0; i < n; i++) {

    if (W[i] == n - 1)
        continue;

    int nxt = W[P[i] + 1];

    while (max(i, nxt) + current_lcp < n && 
           val[i + current_lcp] == val[nxt + current_lcp]) {
            current_lcp++;
        }

    L[W[i]] = current_lcp;
    current_lcp = max(0, current_lcp - 1);
}
\end{lstlisting}

Наивное прибавление мы делаем не более чем $n$ раз, значит сложность алгоритма  $O(n)$
