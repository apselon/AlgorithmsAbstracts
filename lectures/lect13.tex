\section{Сложность вычислений.}%
\label{sec:Сложность вычислений.}

Всю свою жизнь вы занимались Fine-grained complexity, 
то есть имея алгоритм за $O(n^2)$ сделать алгоритм за  $O(n\log n)$.

В сложности вычислений мы отходим от тонких материй, переставая различать $O(n)$ и  $O(n^2)$ 
и будем считать эффективными -- задачи класса  $P$.

\begin{Def}
    \textbf{Класс задач P} --- класс задач, которые решаются за полиномиальное время.
\end{Def}

Кроме того, мы поймем какие задачи на сегодняшний день не представляется возможным решать за $O(poly(n))$.

\subsection{Машина Тьюринга.}%
\label{sub:Машина Тьюринга.}
\begin{Def}
    \textbf{Машина Тьюринга} --- набор объектов $(\Sigma, \Gamma, Q, \delta, q_s, q_a, q_r)$, где :
    \begin{itemize}
        \item $\Sigma$ --- входной алфавит, символы, которые могут быть переданы на вход.
        \item $\Gamma$ --- ленточный алфавит, то что может быть напечатано на ленту. 
            $\Sigma \subset \Gamma$, $\# \in \Gamma$ --- пробельный символ, $\Gamma$ --- конечно.
        \item $Q$ --- множество состояний, $Q$ --- конечно.
        \item $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, N, R\}$ --- функция переходов, 
            получив состояние и символ, она вернет состояние, в которое нужно перейти, символ, который нужно вывести, 
            а также направление, по которому нужно сдвинуться по ленте.
        \item $q_s$ --- стартовое состояние.
        \item $q_a$ --- терминальное состояние, свидетельствующее о том, что полученное слово --- хорошее.
        \item $q_r$ --- терминальное состояние, свидетельствующее о том, что полученное слово --- плохое.
    \end{itemize}
\end{Def}

То есть наша машина будет рассматривать слово, определяя, лежит ли оно в языке, и давать бинарный ответ --- да или нет.

Не будем формально вводить вычисление, интуитивно говоря, мы имеем полоску бумаги, разделенную на клетки, изначально заполненные пробелами.
На каком-то куске ленты написано входное слово $x \in \Sigma^*$, которе мы будем определять на принадлежность рассматриваемому языку.

\begin{example}
   Правда ли что $x$ --- правильная скобочная последовательность.
\end{example}

В начальной конфигурации головка указывает на начало слова $x$ и машина находится в состоянии  $q_s$. 
На каждый такт работы машины, мы применяем функцию  $\delta$. Сама функция как бы зашита в управляющее устройство машины. 

Применение  $\delta$ продолжается пока мы не придем в терминальное состояние  $q_a$ или  $q_r$.

\begin{Def}
     Будем говорить, что \textbf{машина распознает язык $L \subset \Sigma^*$ за время $T$}, 
     если при любом входе из языка $L$ она приходит в верное терминальное состояние не больше чем за $T$. 
\end{Def}

\subsubsection{Многоленточная машина.}
\begin{Def}
    \textbf{Многоленточная машина Тьюринга} --- набор объектов $(\Sigma, \Gamma, Q, \delta, k, q_s, q_a, q_r)$, где:
    \begin{itemize}
        \item $k$ --- количество лент.
        \item $\delta: Q \times \Gamma^k \rightarrow Q \times \Gamma^k \times \{L, N, R\} ^ k$.
    \end{itemize}
\end{Def}

То есть на каждой ленте есть своя головка, которая по ней перемещается, независимо от других головок.

\begin{theorem}
    Если язык $L$ распознается на  $k$-ленточной машине за  $T(n)$, то существует одноленточная машина, распознающая $L$ за  $O(k \cdot T^2(n)$ 
\end{theorem}

\begin{note}
    Именно поэтому не имеет смысла различать по эффективности полиномиальное время. 
\end{note}

\begin{Def}
    $DTIME(T(n))$ ---  класс языков, которые распознаются за $T$ на многоленточной машине.
\end{Def}

\begin{Def}
    Класс языков $P$ ---  $\bigcup \limits_{c = 1}^{\infty} DTIME(n^c)$.
\end{Def}

\begin{Def}
    Класс языков $EXP$ ---  $\bigcup \limits_{c = 1}^{\infty} DTIME(2^{n^c})$.
\end{Def}

\subsubsection{Недетерминированная машина.}
\begin{Def}
    \textbf{Недетерминированная машина Тьюринга} --- набор объектов $(\Sigma, \Gamma, Q, \delta, k, q_s, q_a, q_r)$, где:
    \begin{itemize}
        \item $\delta: Q \times \Gamma ^ k \rightrightarrows Q \times \Gamma ^k \times \{L, N, R\} ^ k$. --- многозначная функция, 
            то есть для одного входного значения есть несколько переходов, из них мы выбираем произвольно. 
    \end{itemize}
\end{Def}

\begin{Def}
   Недетерминированная машина \textbf{принимает слово $x$} если хотябы в одной из ветвей вычислений достигается $q_a$. 
\end{Def}
\begin{Def}
   Говорим что $M$ отвергает  $x$, если она его не принимает. 
   Время работы --- максимальная длина ветви.
\end{Def}

\begin{Def}
    $NTIME(T(n))$ --- класс языков, которые распознаются на недетерминированной машине Тьюринга за время  $T(n)$.
\end{Def}

\begin{Def}
    $NP$ --- $\bigcup \limits_{c = 1}^{\infty} NTIME(n^c)$.
\end{Def}

\begin{note}
   Здесь $NP$ ---  \textbf{Nondeterministic-polynomial}, а вовсе не Non-polynomial. 
\end{note}

\begin{theorem}
   $P \subset NP \subset EXP$ 
\end{theorem}
\begin{proof} \ \\
   Перво вложение верно очевидным образом. \\
   Второе вложение верно так как в каждой точке имеется константное количество ветвлений переходов, а значи их все можно смоделировать за экспоненциальное время.
\end{proof}

\begin{Def}
    Язык $A$ \textbf{сводится полиномиально к} языку $B$: $A \leq_p B$ --- 
    существует полиномиально-вычислимая функция  $f: \forall x \hookrightarrow x \in A \iff f(x) \in B$.
\end{Def}
\begin{note}
    То есть мы можем однозначно определить лежит ли $x$ в  $A$, определив принадлежность $f(x)$ к $B$.
\end{note}

\begin{Def}
   \textbf{NP-трудный} --- язык, такой что $\forall A \in NP \hookrightarrow A \leq_p B$
\end{Def}

\begin{Def}
   \textbf{NP-полный} --- NP-трудный язык, который и сам лежит в  $NP$.
\end{Def}
\begin{note}
   То есть это значит самый сложный в классе NP. 
\end{note}

\begin{example}
    Примеры NP-полных языков. 
    \begin{itemize}
        \item $SAT = \{\phi: phi \text{ пропозициональная выполнимая формула. \}}$
        \item $CLIQUE = \{(G, k): \omega(G) \geq k\}$.
        \item $COL = \{(G, k): \chi(G) \leq k\}$.
        \item $DHAMPATH = \{G: \text{ в нем есть гамильтонов путь. }\}$
    \end{itemize} 
\end{example}

\begin{theorem}
    $A \in NP \iff \exists \text{ детерм. машина }  V(x, s), \text{ работающая за poly(x) }: \\
        \forall x \hookrightarrow x \in A \iff \exists s: V(x, s) = 1$
\end{theorem}
\begin{note}
    Машина $V$ называется верификатором. 
    Аргумент $s$ называется сертификатом. \\
    Концептуально условие означает, что какой бы мы сертификат не предложили машине, она не назовет слово не из $A$ хорошим. \\
    То есть принадлежность языка классу $NP$ означает, что для каждого из его слов есть какой-то сертификат, убеждающий машину в том, что это слово хорошее.
    Таким образом принадлежность к $A \in NP$ легко проверить.
\end{note}

\begin{example}
    При помощи теоремы проверим, что языки действительно принадлежать $NP$.
    \begin{itemize}
        \item $SAT$ --- действительно, в качестве сертификата можем передать тот самый набор, который выполняет $\phi$.
        \item $CLIQUE$ --- в качестве сертификата передадим те самые $k$ вершин, образующие клику. 
        \item $COL$ --- сертификат это раскраска в $k$ цветов.
        \item $DHAMPATH$ --- гамильтонов путь. 
    \end{itemize} 
\end{example}

\begin{theorem} \ (Кука -- Левина) \\
   $SAT$ ---  NP-полный язык. 
\end{theorem}
\begin{proof} \ \\
    Построив сертификат мы уже доказали что язык лежит в классе NP, теперь покажем что он NP-трудный. \\
    Для этого покажем, что любой язык из NP можно к нему свести: \\
    Пусть $L \in NP$ то есть имеется детерм. машина $V(x, s)$, работающая за poly($\lvert x \rvert$), такая что 
    $\forall x \hookrightarrow x \in L \iff \exists s: V(x, s) = 1$. \\

    Тогда для заданного $s$ запишем всю цепочку вычислений машины до того как она придет в  $q_a$. \\
    На каждом такте головка перемещается не более чем на одну клетку, а значит если машина работает за полиномиальное время,
    то и перемещение головки также будет полиномиальным. То есть нашу рассматриваемую область 
    можно ограничить на poly($x$) до начала входных данных и на poly($x$) после начала входа. \\
    Будем рассматривать таблицу, каждая строка котрой --- рассматриваемая часть ленты на некотором шаге. Ее высота также poly(x) \\
    Заведем булеву функцию $\psi$, которая будет кодировать корректность вычисления, а именно то, что:
    \begin{itemize}
        \item Стартовая конфигурация именно та, которая нужна: $(q_start, x, s)$
        \item Каждая следующая строка получается из предыдущей с помощью перехода по  $\delta$.
        \item В последней строке есть  $q_a$.
    \end{itemize}
    Каждая из ячеек таблицы будет переменной $\psi$. При этом можно утверждать, что вся таблица кроме некоторой фиксированой части, 
    которая строится по входным данным $s$, фиксирована, тогда: \\
    $x \in L \iff \exists s: \psi(s) = 1$. То есть $x$ лежит в языке если вычисление можно сделать корректным, подставив некоторый сертификат. \\
    Теперь будем кодировать все символы из исходного алфавита $\Sigma$ последовательностями битов фиксированной длины, например $10$. 
    Теперь ячейка машины Тьюринга будет соответствовать 10 булевым переменным.  \\
    <...> Я вижу тут долгое рассуждение доказывающее корректность, а вы? \\
    Таким образом,  $SAT$ --- NP-трудный язык, а значит и NP-полный.

    


\end{proof}
